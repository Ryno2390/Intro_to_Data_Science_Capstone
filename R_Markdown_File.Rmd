---
title: "R_Markdown_File"
author: "RStudio"
date: "10/9/2018"
output: html_document
URL: https://github.com/Ryno2390/Intro_to_Data_Science_Capstone.git
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Questions to Answer

## What is the problem you want to solve?

Analyze U.S. polling data during the 2016 presidential election in order to create a model that would not only predict who would have won the 2016 Presidential election, but would also provide actionable intelligence to a presidential campaign.

## Who is your client and why do they care about this problem? In other words, what will your client DO or DECIDE based on your analysis that they wouldnâ€™t have otherwise?

Presidential campaigns are big business. The final price tag for the 2016 election was $6.5 billion for the presidential and congressional elections combined, according to campaign finance watchdog OpenSecrets.org (https://www.opensecrets.org/news/2017/04/election-2016-trump-fewer-donors-provided-more-of-the-cash/), with the presidential race, alone, responsible for $2.4 billion of that total.

Needless to say, there are a lot of interested parties when it comes to the outcome of elections - perhaps the most interested party being that of the campaigns themselves. Of the $2.4 billion spent on the presidential campaigns in 2016, $398 million was spent by the Trump campaign, and a whopping $768 million was spent by the Clinton campaign, a sizable percentage of which was spent on data and analytics.

For this project I will be assuming that my main client is the Clinton campaign. My job, in this hypothetical scenario, is to build model that could not only predict who would win the election (based on readily available polling data) but also how to proceed strategically - specifically, which states to campaign in and which to avoid.

This type of information is valuable to campaigns as campaigns face budget constraints. Though the Clinton campaign spent a large amount of money during the 2016 campaign, the campaign's budget was not infinite; all campaigns have to make strategic decisions about how to optimally allocate the limited resources at their disposal.

To aid the campaign in making resource allocation decisions, my model will be designed to provide answers to two basic questions:

1. What states should the Clinton campaign focus on (i.e. to determine which states are "swing" states)?
2. Which candidate is most likely to win in each state - Clinton or Trump?

## What data are you going to use for this? How will you acquire this data?

I will use FiveThirtyEight.com's data which is readily available through Kaggle.com (https://www.kaggle.com/fivethirtyeight/2016-election-polls#presidential_polls.csv)

## In brief, outline your approach to solving this problem (knowing that this might change later).

My approach will be to create a machine learning program that will be able to incorporate new, raw polling data in order to categorize states according to status: Clinton supporting, Trump Supporting, or Swing. I will attempt to do this using an unsupervised, k-means clustering method. 

Using a modified version of this method, I will also categorize states into a simple binary of Clinton and Trump states, updating my prediction of electoral vote totals for each candidate, with The candidate who reaches 270 electoral votes deemed the likely winner.

## What are your deliverables? Typically, this would include code, along with a paper and/or a slide deck.

The deliverables will include:

+ A walkthrough of the model using RMarkdown

+ A detailed summary paper intended for the senior members of the campaign, containing recommednations for campaign allocation of resources and predictions.

# Upload data into RStudio

The first step is to upload FiveThirtyEight's election data to RStudio.

```{r}
library(readr)

Raw_Data <- read_csv("presidential_polls.csv")

str(Raw_Data)
```

There are many superfluous columns in this data set that we can remove. Let's see if we can hone and clean our data set. We can exclude the following variables from our final data set (I have also provided a quick explanation as to why a particular variable has been excluded):

+ cycle - all values are the same (i.e. set to "2016")

+ branch - all values are the same (i.e. set to "Presidential")

+ type - this determines which model FiveThirtyEight associates with each poll (i.e. "Now-Cast", "Polls-Only", or "Polls-Plus")

+ matchup - all values are the same (i.e. set to "Clinton vs. Trump vs. Johnson")

+ forecastdate - all values are the same (i.e. set to "11/1/2016")

+ rawpoll_johnson - my model will only compare voting patterns between the final two presidential candidates (i.e. Clinton and Trump) and therefore will exclude data for both Johnson and McMullin

+ rawpoll_mcmullin - my model will only compare voting patterns between the final two presidential candidates (i.e. Clinton and Trump) and therefore will exclude data for both Johnson and McMullin

+ adjpoll_johnson - my model will only compare voting patterns between the final two presidential candidates (i.e. Clinton and Trump) and therefore will exclude data for both Johnson and McMullin

+ adjpoll_mcmullin - my model will only compare voting patterns between the final two presidential candidates (i.e. Clinton and Trump) and therefore will exclude data for both Johnson and McMullin

+ multiversions - this field denotes if there were multiple versions of the same poll. My analysis will not make such a distinction and will simply take each poll at face value.

+ url - links to the original poll data location.

+ poll_id - unique identifier used by FiveThirtyEight to identify polls in other models.

+ question_id - unique identifer to determine the form of the poll question. I do not have access to the reference table for these questions so this will not be included in our data set.

+ createddate - date the data was inputted to the FiveThirtyEight's model, which is irrelevant for my data set.

+ timestamp - date the model was rerun incorporating all the data up to that point. The model was last updated November 1st, 2018 and is irrelevant to my data set.

## This leaves the following fields in my final data set:

+ state - the state from which the poll was taken (the value "U.S." signifies a national poll)

+ startdate - the date on which the poll was begun

+ enddate - the date on which the poll was ended

+ pollster - the organization that conducted the poll

+ grade - the accuracy rating of the polling organization. FiveThirtyEight determines this grade by analyzing a pollster's past predictions and comparing them to actual results. The more accurate the pollster the higher the grade.

+ samplesize - the size of the sample for the poll (i.e. the "n" value)

+ population - a unique regional identifier that FiveThirtyEight uses in their model. I may or may not use this variable so I will tentatively keep it in my final dataset.

+ poll_wt - the weight assigned to each poll predicated on the polling organization's grade

+ rawpoll_clinton - the raw percentage of respondents polled who plan on voting for Hillary Clinton

+ rawpoll_trump - the raw percentage of respondents polled who plan on voting for Donald Trump

+ adjpoll_clinton - the weight-adjusted percentage of respondents polled who plan on voting for Hillary Clinton

+ adjpoll_trump - the weight-adjusted percentage of respondents polled who plan on voting for Donald Trump

# Remove superfluous columns from the data set to produce a clean data set

Now that I have chosen the final variables for my data set the next step is to exclude the superflous variables. We can do this easily using the dplyr package.

```{r}
library(dplyr)

Clean_Data <- Raw_Data %>% select(-c(cycle:forecastdate, rawpoll_johnson, rawpoll_mcmullin, adjpoll_johnson:timestamp))

str(Clean_Data)
```

A quick overview of the "state" column reveals that there are really two different types of polls: purely state polls (which include specific congressional districts, as well as state-wide polls) and national polls. To get our bearings I will apply some statistics to the national polling data first.

## Filter the data to include only "U.S." - or national - polls

Next, let's create a subset of that data containing only national polling data. Let's also exclude some additional variables, opting for a simplified data set containing only the following variables:

1. state
2. enddate
4. rawpoll_clinton
5. rawpoll_trump

I will install the lubridate package, which will allow me to convert my date variable (enddate) into a more universally readable format (mdy - month, day, year)

```{r}
install.packages("lubridate")
library(lubridate)

National_Polls <- Clean_Data %>% 
  select(state, enddate, rawpoll_clinton, rawpoll_trump) %>%
  filter(state == "U.S.") %>%
  mutate(enddate = mdy(enddate)) %>%
  arrange(enddate)

summary(National_Polls)
```

A look at the summary of the data reveals some important, baseline statistics. First, it provides us with the total number of observations - i.e. the number of national polls: 3,105. 

The data also provides us with timeframe over which these polls were conducted: November 11th, 2016 through October 31st, 2016 - about 1 year's worth of data. 

It also appears that Clinton's raw mean polling data is higher than Trump's: 43.91% vs. 39.43%, respectively. Finally, the median raw polling data for both Clinton and Trump are not very far from their means - signifying a lack of extreme outliers.

Now that we undertsand the data a little bit better, let's do a simple scatter plot of the the rawpoll_clinton and rawpoll_trump variables over time (i.e. by enddate) to see if there are any obvious patterns. Let's start with Clinton's raw polling data.

## Install ggplot2 and plot the rawpoll_clinton data over time to see if there are any obvious patterns.

```{r}
install.packages("ggplot2")
library("ggplot2")

rawpoll_Clinton_plot <- ggplot(data = National_Polls, aes(x=enddate, y=rawpoll_clinton)) +
  geom_point(color = "blue")

print(rawpoll_Clinton_plot + ggtitle("Raw National Clinton Polls"))
```

Now, let's do the same for Trump's raw polling data.

```{r}
rawpoll_Trump_plot <- ggplot(data = National_Polls, aes(x=enddate, y=rawpoll_trump)) +
  geom_point(color = "red")

print(rawpoll_Trump_plot + ggtitle("Raw National Trump Polls"))
```

One obvious pattern that stands out is that the number of polls increases over time. This makes sense, since as we get closer to election day, more and more polls are conducted in order to determine who the likely winner will be. 

Another obvious pattern is that the variation in the polls also increase over time - like a funnel that widens over time. 

Perhaps the most important point to make about the data is that it is quite "noisy" - even temporally close polls can drastically differ in predicted outcome. Smoothing out the data could be helpful in teasing out a meaningful pattern. 

One potentially useful smoothing technique is a moving average - a rolling average of predefined number of polls. A moving average can help us find the "signal" amongst the "noise".

Let's apply a 100 poll moving average to Clinton's raw polling data and plot it over time. This will provide us with a moving average of the last 100 polls.

To do this, we will need to install another package called "zoo", which provides us with a simple function (rollmean) to calculate a moving average.

```{r}
install.packages("zoo")
library(zoo)

National_Polls <- National_Polls %>%
  mutate(Clinton_MA = rollmean(rawpoll_clinton, 100, na.pad=TRUE, align="right"))

Clinton_MA_plot <- ggplot(data = National_Polls, aes(x=enddate, y=Clinton_MA)) +
  geom_line(color = "blue")

print(Clinton_MA_plot + ggtitle("Clinton 100 Poll Moving Average"))
```

Let's now do the same for Trump's raw polling data.

```{r}
National_Polls <- National_Polls %>%
  mutate(Trump_MA = rollmean(rawpoll_trump, 100, na.pad=TRUE, align="right"))

Trump_MA_plot <- ggplot(data = National_Polls, aes(x=enddate, y=Trump_MA)) +
  geom_line(color = "red")

print(Trump_MA_plot + ggtitle("Trump 100 Poll Moving Average"))
```

After smoothing out the data we can see some clear patterns. Early on in the cycle it appears that Clinton had an early and substantial lead in the national polls (though this is tempered by the fact that there were fewer polls during this period). 

However, this early and substantial lead appears to erode over the summer, improving in the fall but never fully regaining those early hights. In contrast, Trump's polling data improved over time, starting around July, and spiking in the final weeks of the campaign

So far, the data has been separated into two columns, containing polling data for each candidate. Though this is useful, what really matters in elections is which candidate wins a higher percentage of the vote. In other words, what we want to know is the margin between Clinton and Trump.

Since Clinton is our hypothetical client, we will subtract Trump's polling figures from Clinton's to arrive at a Clinton_Margin figure. A positive figure indicates that Clinton leads Trump in the national polls and a negative figure indicates that Clinto is trailing Trump in the national polls.

## Calculate the Clinton - Trump margin and plot it over time.

```{r}
National_Polls <- National_Polls %>%
  mutate(Clinton_Margin = Clinton_MA - Trump_MA)

Clinton_Margin_plot <- ggplot(National_Polls, aes(x=enddate, y=Clinton_Margin)) +
  geom_line(color = "purple")

print(Clinton_Margin_plot + ggtitle("Clinton 100 Poll Moving Average"))
```

Using this visualization of margin we can see more clearly the pattern of Clinton's chances of winning the presidency. We see an early rise in her chances as she widened her margin from January through May. However, her chances deteriorated throughout the Summer and Fall - reaching their lowest point in August (where it was actually net negative for the first, and only, time during the campaign), only to regain in mid-September through mid-October period, preciptously falling back down in late October. If this late, falling trend were extended through election day (i.e. November 6th, 2016), it's entirely plausible that Clinton would have had a net negative margin on election day.

# This is NOT a popularity contest

This is all very interesting, but in American presidential elections the president is chosen not through the popular vote but through the Electoral College. In the Electoral College each state recieves a total number of electoral votes equal to its representation in Congress. 

More specifically, each state's total number of electors is equal to the combined total of the state's membership in the Senate and House of Representatives; currently there are 100 senators (2 for each state) and 435 representatives. Additionally, the Twenty-third Amendment of the U.S. Constitution dictates that the District of Columbia (which is NOT a state) is entitled to a number of electors no greater or less than that of the least populous state (i.e. 3 electoral votes), for a total of 538 electoral votes.

Therefore, to win, an American presidential candidate must win an absolute majority of 270 electoral votes to become president. Therefore, in order to create a model that accurately predicts who will become president, and NOT who will win the most votes, we need to predict the winner in each state, and allocate each state's electoral votes to the predicted winner of each state. The first candidate to 270 wins!

## "Swing" for the Fences!

One of the most important jobs of a presidential campaign is to determine where to campaign. Every campaign is constrained by its limited resources (volunteers, money, advertisting, ect.), so each campaign must make strategic decisions about which states to campaign in. 

It does not make sense for a campaign to commit resources to a state that is highly unlikely to vote for its candidate, nor does it make sense for a campaign to do the opposite; it makes little sense to commit resources to a state that is already highly likely to vote for you. Therefore, the optimal use of limited campaign resources is to devote them to "swing" states - states that could vote for either you or your opponent.

Toward this end, a k-means clustering model would help us in determining which states are considered solidly Clinton, which states are solidly Trump, and - most importantly - which states are swing states. By choosing a k = 3, we subdivide the states into Clinton, Trump, and Swing.

First we need to create a State specific data set which we will call "State_Polls_Swing". This data set will pull in the same variable as we had in the National polling data but would exclude national polls or district specific polls. 

It is important to note that some states allocate electoral votes by congressional district instead of in a "winner-take-all" fashion. Currently, only two states do so - Maine and Nebraska - but for the sake of simplicity we will assume that as the state goes, so go the congressional districts. Therefore, we will remove any district specific polls in our data. 

We will also create a "Clinton_Margin" variable - similar to our difference in moving averages margin but which in this instance is calculated by subtracting Trump's raw polling numbers from Clinton's.

Finally, we also wish to only calculate our k-means clusters using unique polling data so we will modify our polling data to only include unique polls. 

```{r}
State_Polls_Swing <- Clean_Data %>%
  select(state, pollster, rawpoll_clinton, rawpoll_trump) %>%
  filter(state != "U.S.") %>%
  filter(state != "Maine CD-1") %>%
  filter(state != "Maine CD-2") %>%
  filter(state != "Nebraska CD-1") %>%
  filter(state != "Nebraska CD-2") %>%
  filter(state != "Nebraska CD-3") %>%
  mutate(Clinton_Margin = rawpoll_clinton - rawpoll_trump)
str(State_Polls_Swing)
```

When it comes to selecting a k value for our k-means cluster model, we understand through pre-existing domain knowledge that states often fall into one of three categories: deep red or Republican states, deep blue or Democratic states, and swing state - states that will often swing back and forth between the two parties depending on the candidates. Therefore, we should choose a k value of 3.

We can confirm or deny this inclination using a scree plot. A scree plot charts the degree of scattering or variance inside a cluster as the total number of clusters increase. A scree plot compares the Sum of Squared Errors (SSE) - measured as the sum of the squared distances between the centroid and the other neighbors inside the cluster. Generally, SSE drops as more clusters are created. 

In general, we should opt for a number of clusters where the SSE decreases dramatically to the left on our plot, but before it reaches a point of little to no chage as the number of clusters increases (i.e. as we move right along the grapth). If this dramatic drop (often referred to as an "eblow") occurs when the number of clusters is equal to 3, we can be confident that our selection of k = 3 is legitimate.

```{r}
State_Polls_Scree <- State_Polls_Swing$Clinton_Margin

df <- scale(State_Polls_Scree)

wssplot <- function(data, nc=15, seed=1234){
	              wss <- (nrow(data)-1)*sum(apply(data,2,var))
               	      for (i in 2:nc){
		        set.seed(seed)
	                wss[i] <- sum(kmeans(data, centers=i)$withinss)}
	                
		      plot(1:nc, wss, type="b", xlab="Number of Clusters",
	                        ylab="Within groups sum of squares")
	   }

wssplot(df)
```

The scree plot, indeed, confirms our inclination that k should be equal to 3. This will ensure that these three cluster solutions are distinct and will have a significant impact on our classification of the states.

Now that we have calculated our Clinton_Margin variable we can remove the rawpoll_clinton and rawpoll_trump variables. Next we will calculate the euclidean distance amongst Clinton's polling margins and set k equal to 3. 

```{r}
State_Polls_Swing$rawpoll_clinton = NULL
State_Polls_Swing$rawpoll_trump = NULL
State_Polls_Swing <- unique(State_Polls_Swing)

distances_Swing <- dist(State_Polls_Swing, method = "euclidean")
clusterStates_Swing <- hclust(distances_Swing, method = "ward")
clusterGroups_Swing <- cutree(clusterStates_Swing, k = 3)
```

Next, we will see how each state's polls are assigned: are they assigned in such a way that they fall into the solidly Trump leaning category, solidly Clinton leaning category, or the swing category?

We will do this by the pulling cluster groups associated with each state's polling margins, take a mean of the assignments and round it to the nearest whole number to determine which of the three sets it fall into.

For example, if we pull Alabam's cluster groups, we see each margin's assignment: 3 indicating that the margin indicates a solidly Trump state, a 2 indicating that the state is a swing states, and a 1 indicating a solidly Clinton state.

```{r}
clusterGroups_Swing[State_Polls_Swing$state == "Alabama"]
```

If we take the mean of these assignments we get an indication of how Trump or Clinton leaning a state is. Let's take Alabama as an example once again.

```{r}
mean(clusterGroups_Swing[State_Polls_Swing$state == "Alabama"])
```

Finally, if we round this mean, we can determine which of the three clusters the state belongs to. In the case of Alabama we see that this state is solidly Trump supporting.

```{r}
round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Alabama"]))
```

If we perform this same calculation for each state we can assign each state to one of our three assignments - solidly Trump (indicated by a 3), solidly Clinton (indicated by a 1), or swing (indicated by a 2)

```{r}
# Alabama
Alabama_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Alabama"]))
Alabama_Cluster_Swing

# Alaska
Alaska_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Alaska"]))
Alaska_Cluster_Swing

# Arizona
Arizona_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Arizona"]))
Arizona_Cluster_Swing

# Arkansas
Arkansas_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Arkansas"]))
Arkansas_Cluster_Swing

# California
California_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "California"]))
California_Cluster_Swing

# Colorado
Colorado_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Colorado"]))
Colorado_Cluster_Swing

# Connecticut
Connecticut_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Connecticut"]))
Connecticut_Cluster_Swing

# District of Columbia
District_of_Columbia_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "District of Columbia"]))
District_of_Columbia_Cluster_Swing

# Delaware
Delaware_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Delaware"]))
Delaware_Cluster_Swing

# Florida
Florida_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Florida"]))
Florida_Cluster_Swing

# Georgia
Georgia_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Georgia"]))
Georgia_Cluster_Swing

# Hawaii
Hawaii_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Hawaii"]))
Hawaii_Cluster_Swing

# Idaho
Idaho_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Idaho"]))
Idaho_Cluster_Swing

# Illinois
Illinois_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Illinois"]))
Illinois_Cluster_Swing

# Indiana
Indiana_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Indiana"]))
Indiana_Cluster_Swing

# Iowa
Iowa_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Iowa"]))
Iowa_Cluster_Swing

# Kansas
Kansas_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Kansas"]))
Kansas_Cluster_Swing

# Kentucky
Kentucky_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Kentucky"]))
Kentucky_Cluster_Swing

# Louisiana
Louisiana_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Louisiana"]))
Louisiana_Cluster_Swing

# Maine
Maine_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Maine"]))
Maine_Cluster_Swing

# Maryland
Maryland_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Maryland"]))
Maryland_Cluster_Swing

# Massachusetts
Massachusetts_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Massachusetts"]))
Massachusetts_Cluster_Swing

# Michigan
Michigan_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Michigan"]))
Michigan_Cluster_Swing

# Minnesota
Minnesota_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Minnesota"]))
Minnesota_Cluster_Swing

# Mississippi
Mississippi_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Mississippi"]))
Mississippi_Cluster_Swing

# Missouri
Missouri_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Missouri"]))
Missouri_Cluster_Swing

# Montana
Montana_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Montana"]))
Montana_Cluster_Swing

# Nebraska
Nebraska_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Nebraska"]))
Nebraska_Cluster_Swing

# Nevada
Nevada_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Nevada"]))
Nevada_Cluster_Swing

# New Hampshire
New_Hampshire_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "New Hampshire"]))
New_Hampshire_Cluster_Swing

# New Jersey
New_Jersey_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "New Jersey"]))
New_Jersey_Cluster_Swing

# New Mexico
New_Mexico_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "New Mexico"]))
New_Mexico_Cluster_Swing

# New York
New_York_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "New York"]))
New_York_Cluster_Swing

# North Carolina
North_Carolina_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "North Carolina"]))
North_Carolina_Cluster_Swing

# North Dakota
North_Dakota_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "North Dakota"]))
North_Dakota_Cluster_Swing

# Ohio
Ohio_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Ohio"]))
Ohio_Cluster_Swing

# Oklahoma
Oklahoma_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Oklahoma"]))
Oklahoma_Cluster_Swing

# Oregon
Oregon_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Oregon"]))
Oregon_Cluster_Swing

# Pennsylvania
Pennsylvania_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Pennsylvania"]))
Pennsylvania_Cluster_Swing

# Rhode Island
Rhode_Island_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Rhode Island"]))
Rhode_Island_Cluster_Swing

# South Carolina
South_Carolina_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "South Carolina"]))
South_Carolina_Cluster_Swing

# South Dakota
South_Dakota_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "South Dakota"]))
South_Dakota_Cluster_Swing

# Tennessee
Tennessee_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Tennessee"]))
Tennessee_Cluster_Swing

# Texas
Texas_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Texas"]))
Texas_Cluster_Swing

# Utah
Utah_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Utah"]))
Utah_Cluster_Swing

# Vermont
Vermont_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Vermont"]))
Vermont_Cluster_Swing

# Virginia
Virginia_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Virginia"]))
Virginia_Cluster_Swing

# Washington
Washington_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Washington"]))
Washington_Cluster_Swing

# West Virginia
West_Virginia_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "West Virginia"]))
West_Virginia_Cluster_Swing

# Wisconsin
Wisconsin_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Wisconsin"]))
Wisconsin_Cluster_Swing

# Wyoming
Wyoming_Cluster_Swing <- round(mean(clusterGroups_Swing[State_Polls_Swing$state == "Wyoming"]))
Wyoming_Cluster_Swing
```

If we then assign electoral votes to each candidate based on the states that are solidly Trump or solidly Clinton we arrive at the following results (along with the electoral votes associated with each state):

## Solidly Clinton States

1. California (55)
2. Colorado (9)
3. Connecticut (7)
4. Delaware (3)
5. District of Columbia (3)
6. Hawaii (4)
7. Illinois (20)
8. Maine (4)
9. Maryland (10)
10. Massachusetts (11)
11. Michigan (16)
12. Minnesota (10)
13. New Hampshire (4)
14. New Jersey (14)
15. New Mexico (5)
16. New York (29)
17. Oregon (7)
18. Pennsylvania (20)
19. Rhode Island (4)
20. Vermont (3)
21. Virginia (13)
22. Washington (12)
23. Wisconsin (10)

Total Electoral Votes: 273

## Solidly Trump States

1. Alabama (9)
2. Arkansas (6)
3. Idaho (4)
4. Kentucky (8)
5. Louisiana (8)
6. Mississippi (6)
7. Montana (3)
8. Nebraska (5)
9. North Dakota (3)
10. Oklahoma (7)
11. South Dakota (3)
12. Tennessee (11)
13. West Virginia (5)
14. Wyoming (3)

Total Electoral Votes: 81

## Swing States

1. Alaska (3)
2. Arizona (11)
3. Florida (29)
4. Georgia (16)
5. Indiana (11)
6. Iowa (6)
7. Kansas (6)
8. Missouri (10)
9. Nevada (6)
10. North Carolina (15)
11. Ohio (18)
12. South Carolina (9)
13. Texas (38)
14. Utah (6)

Total Electoral Votes: 184

The model indicates that though Clinton holds what seems like a commanding, and potentiall winnding, lead the substantial list of swing states indicates that this lead is tenuous at best. It is highly unlikely that every single Clinton leaning state will break for Clinton - nor is it likely that every single Trump leaning state will break for Trump. All it takes is for one small Clinton leaning state to swing for Trump and for the swing states, in general, to break for Trump for Clinton to lose. That may seem unlikely, but crazier things have happened in presidential elections. 

To better understand our swing states let's looks at their unrounded mean cluster group values to determine whether they are Clinton leaning or Trump leaning.

```{r}
# Alaska
mean(clusterGroups_Swing[State_Polls_Swing$state == "Alaska"])
Alaska_Data <- Clean_Data %>%
  filter(state == "Alaska")

# Arizona
mean(clusterGroups_Swing[State_Polls_Swing$state == "Arizona"])
Arizona_Data <- Clean_Data %>%
  filter(state == "Arizona")

# Florida
mean(clusterGroups_Swing[State_Polls_Swing$state == "Florida"])
Florida_Data <- Clean_Data %>%
  filter(state == "Florida")

# Georgia
mean(clusterGroups_Swing[State_Polls_Swing$state == "Georgia"])
Georgia_Data <- Clean_Data %>%
  filter(state == "Georgia")

# Indiana
mean(clusterGroups_Swing[State_Polls_Swing$state == "Indiana"])
Indiana_Data <- Clean_Data %>%
  filter(state == "Indiana")

# Iowa
mean(clusterGroups_Swing[State_Polls_Swing$state == "Iowa"])
Iowa_Data <- Clean_Data %>%
  filter(state == "Iowa")

# Kansas
mean(clusterGroups_Swing[State_Polls_Swing$state == "Kansas"])
Kansas_Data <- Clean_Data %>%
  filter(state == "Kansas")

# Missouri
mean(clusterGroups_Swing[State_Polls_Swing$state == "Missouri"])
Missouri_Data <- Clean_Data %>%
  filter(state == "Missouri")

# Nevada
mean(clusterGroups_Swing[State_Polls_Swing$state == "Nevada"])
Nevada_Data <- Clean_Data %>%
  filter(state == "Nevada")

# North Carolina
mean(clusterGroups_Swing[State_Polls_Swing$state == "North Carolina"])
North_Carolina_Data <- Clean_Data %>%
  filter(state == "North Carolina")

# Ohio
mean(clusterGroups_Swing[State_Polls_Swing$state == "Ohio"])
Ohio_Data <- Clean_Data %>%
  filter(state == "Ohio")

# South Carolina
mean(clusterGroups_Swing[State_Polls_Swing$state == "South Carolina"])
South_Carolina_Data <- Clean_Data %>%
  filter(state == "South Carolina")

# Texas
mean(clusterGroups_Swing[State_Polls_Swing$state == "Texas"])
Texas_Data <- Clean_Data %>%
  filter(state == "Texas")

# Utah
mean(clusterGroups_Swing[State_Polls_Swing$state == "Utah"])
Utah_Data <- Clean_Data %>%
  filter(state == "Utah")
```

Let's look at these swing states in order of most Clinton leaning to least Clinton leaning (along with each state's electoral votes):

1. Florida (29)
2. Iowa (6)
3. Arizona (11)
4. Ohio (18)
5. North Carolina (15)
6. Nevada (6)
7. Georgia (16)*
8. Kansas (6)*
9. Alaska (3)*
10. Missouri (10)*
11. Utah (6)*
12. South Carolina (9)*
13. Indiana (11)*
14. Texas (38)*

*Indicates that this state leans Republican (i.e. has a mean cluster value greater than 2)

If we eliminate the Republican leaning states we are left with the following list of Democratic leaning swing states:

1. Florida (29)
2. Iowa (6)
3. Arizona (11)
4. Ohio (18)
5. North Carolina (15)
6. Nevada (6)

If we then order this list in descending order of electoral votes, we get the following "hit list" of swing states:

1. Florida (29)
2. Ohio (18)
3. North Carolina (15)
4. Arizona (11)
5. Iowa (6)
6. Nevada (6)

This "hit list", represents the states that, according to the model, Clinton should focus on in order to improve her chances of reaching 270 electoral votes. 

Thus, we have reached our first recommendation for the Clinton campaign: based on the polling data and our machine learning model, the Clinton campaign should focus on Florida and Ohio, along with North Carolina and Arizona if time and resources permit. It makes little sense for the Clinton campaign to waste time and resources on the relatively small number of electoral votes represented by the states of Iowa or Nevada, nor should the Clinton campaign commit resources to the Trump leaning swing states of Georgia, Kansas, Alaska, Missouri, Utah, South Carolina, Indiana, or Texas.

# Great! But Who Will Win?

What is elegant and - most important - simple about our k-means clustering model is that we can dial up or down the k-value depending on the question we want to answer. We have aleeady answered the swing state question by choosing a k-value of 3, but if we want to answer our final question - who will win the election - we will need a k-value of 2.

By choosing a k-value of 2, we split the decision into a binary choice: either Clinton wins a given state or she loses; 1 or 2. By simply modifying our k-value we can rerun our machine learning model to determine a winner in each state and make a final prediction about who will win the election.

Though our scree plot indicated that the data is most accurately divided into 3 catagories, the plot also shows that a k value of 2 is prehaps the second best division of the data, so we can be confident in our results.

We will repeat the process we followed in or swing state model, but set k = 2 instead of 3.

```{r}
State_Polls_Final <- State_Polls_Swing

distances_Final <- dist(State_Polls_Final, method = "euclidean")
clusterStates_Final <- hclust(distances_Final, method = "ward")

clusterGroups_Final <- cutree(clusterStates_Final, k = 2)
```

Let's take a look at each state's predicted result.

```{r}
# Alabama
Alabama_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Alabama"]))
Alabama_Cluster_Final

# Alaska
Alaska_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Alaska"]))
Alaska_Cluster_Final

# Arizona
Arizona_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Arizona"]))
Arizona_Cluster_Final

# Arkansas
Arkansas_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Arkansas"]))
Arkansas_Cluster_Final

# California
California_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "California"]))
California_Cluster_Final

# Colorado
Colorado_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Colorado"]))
Colorado_Cluster_Final

# Connecticut
Connecticut_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Connecticut"]))
Connecticut_Cluster_Final

# District of Columbia
District_of_Columbia_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "District of Columbia"]))
District_of_Columbia_Cluster_Final

# Delaware
Delaware_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Delaware"]))
Delaware_Cluster_Final

# Florida
Florida_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Florida"]))
Florida_Cluster_Final

# Georgia
Georgia_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Georgia"]))
Georgia_Cluster_Final

# Hawaii
Hawaii_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Hawaii"]))
Hawaii_Cluster_Final

# Idaho
Idaho_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Idaho"]))
Idaho_Cluster_Final

# Illinois
Illinois_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Illinois"]))
Illinois_Cluster_Final

# Indiana
Indiana_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Indiana"]))
Indiana_Cluster_Final

# Iowa
Iowa_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Iowa"]))
Iowa_Cluster_Final

# Kansas
Kansas_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Kansas"]))
Kansas_Cluster_Final

# Kentucky
Kentucky_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Kentucky"]))
Kentucky_Cluster_Final

# Louisiana
Louisiana_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Louisiana"]))
Louisiana_Cluster_Final

# Maine
Maine_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Maine"]))
Maine_Cluster_Final

# Maryland
Maryland_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Maryland"]))
Maryland_Cluster_Final

# Massachusetts
Massachusetts_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Massachusetts"]))
Massachusetts_Cluster_Final

# Michigan
Michigan_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Michigan"]))
Michigan_Cluster_Final

# Minnesota
Minnesota_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Minnesota"]))
Minnesota_Cluster_Final

# Mississippi
Mississippi_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Mississippi"]))
Mississippi_Cluster_Final

# Missouri
Missouri_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Missouri"]))
Missouri_Cluster_Final

# Montana
Montana_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Montana"]))
Montana_Cluster_Final

# Nebraska
Nebraska_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Nebraska"]))
Nebraska_Cluster_Final

# Nevada
Nevada_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Nevada"]))
Nevada_Cluster_Final

# New Hampshire
New_Hampshire_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "New Hampshire"]))
New_Hampshire_Cluster_Final

# New Jersey
New_Jersey_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "New Jersey"]))
New_Jersey_Cluster_Final

# New Mexico
New_Mexico_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "New Mexico"]))
New_Mexico_Cluster_Final

# New York
New_York_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "New York"]))
New_York_Cluster_Final

# North Carolina
North_Carolina_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "North Carolina"]))
North_Carolina_Cluster_Final

# North Dakota
North_Dakota_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "North Dakota"]))
North_Dakota_Cluster_Final

# Ohio
Ohio_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Ohio"]))
Ohio_Cluster_Final

# Oklahoma
Oklahoma_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Oklahoma"]))
Oklahoma_Cluster_Final

# Oregon
Oregon_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Oregon"]))
Oregon_Cluster_Final

# Pennsylvania
Pennsylvania_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Pennsylvania"]))
Pennsylvania_Cluster_Final

# Rhode Island
Rhode_Island_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Rhode Island"]))
Rhode_Island_Cluster_Final

# South Carolina
South_Carolina_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "South Carolina"]))
South_Carolina_Cluster_Final

# South Dakota
South_Dakota_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "South Dakota"]))
South_Dakota_Cluster_Final

# Tennessee
Tennessee_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Tennessee"]))
Tennessee_Cluster_Final

# Texas
Texas_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Texas"]))
Texas_Cluster_Final

# Utah
Utah_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Utah"]))
Utah_Cluster_Final

# Vermont
Vermont_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Vermont"]))
Vermont_Cluster_Final

# Virginia
Virginia_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Virginia"]))
Virginia_Cluster_Final

# Washington
Washington_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Washington"]))
Washington_Cluster_Final

# West Virginia
West_Virginia_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "West Virginia"]))
West_Virginia_Cluster_Final

# Wisconsin
Wisconsin_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Wisconsin"]))
Wisconsin_Cluster_Final

# Wyoming
Wyoming_Cluster_Final <- round(mean(clusterGroups_Final[State_Polls_Final$state == "Wyoming"]))
Wyoming_Cluster_Final
```

If we then assign electoral votes to each candidate based on the predicted state outcome we arrive at the following results (along with the electoral votes associated with each state):

## Clinton Wins

1. California (55)
2. Colorado (9)
3. Connecticut (7)
4. Delaware (3)
5. District of Columbia (3)
6. Hawaii (4)
7. Illinois (20)
8. Maine (4)
9. Maryland (10)
10. Massachusetts (11)
11. Michigan (16)
12. Minnesota (10)
13. New Hampshire (4)
14. New Jersey (14)
15. New Mexico (5)
16. New York (29)
17. Oregon (7)
18. Pennsylvania (20)
19. Rhode Island (4)
20. Vermont (3)
21. Virginia (13)
22. Washington (12)
23. Wisconsin (10)

Total Electoral Votes: 273

## Trump Wins

1. Alabama (9)
2. Alaska (3)
3. Arizona (11)
4. Arkansas (6)
5. Florida (29)
6. Georgia (16)
7. Idaho (4)
8. Indiana (11)
9. Iowa (6)
10. Kansas (6)
11. Kentucky (8)
12. Louisiana (8)
13. Mississippi (6)
14. Missouri (10)
15. Montana (3)
16. Nebraska (5)
17. Nevada (6)
18. North Carolina (15)
19. North Dakota (3)
20. Ohio (18)
21. Oklahoma (7)
22. South Carolina (9)
23. South Dakota (3)
24. Tennessee (11)
25. Texas (38)
26. Utah (6)
27. West Virginia (5)
28. Wyoming (3)

Total Electoral Votes: 265

# Defenses Win Championships

What is fascinating about the final results is that the list of solidly Clinton supporting states did not change. Though Clinton's coalition of states is stable, the fact that Trump ran the board on the swing states should worry the Clinton campaign.

This indicates two grand strategies that Clinton could adopt:

## 1. Defensive/Conservative Strategy: Clinton should shore up her base in those states most likely to vote for her. This may not lead to an electoral blow-ou, but it would be the stategy most likely to lead to victory. 

If clinton were to adopt this strategy it would be important for her campaign to know which states in her coalition are most likely to defect to Trump. She should then devote campaign resources to these at-risk states in order to shore up her likelihood of reaching 270 electoral votes.

Let's take a look at the Clinton states' unrounded mean cluster group scores to determine which states are most at risk.

```{r}
# California
California_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "California"])
California_Cluster_Risk

# Colorado
Colorado_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Colorado"])
Colorado_Cluster_Risk

# Connecticut
Connecticut_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Connecticut"])
Connecticut_Cluster_Risk

# Delaware
Delaware_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Delaware"])
Delaware_Cluster_Risk

# District_of_Columbia
District_of_Columbia_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "District of Columbia"])
District_of_Columbia_Cluster_Risk

# Hawaii
Hawaii_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Hawaii"])
Hawaii_Cluster_Risk

# Illinois
Illinois_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Illinois"])
Illinois_Cluster_Risk

# Maine
Maine_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Maine"])
Maine_Cluster_Risk

# Maryland
Maryland_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Maryland"])
Maryland_Cluster_Risk

# Massachusetts
Massachusetts_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Massachusetts"])
Massachusetts_Cluster_Risk

# Michigan
Michigan_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Michigan"])
Michigan_Cluster_Risk

# Minnesota
Minnesota_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Minnesota"])
Minnesota_Cluster_Risk

# New Hampshire
New_Hampshire_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "New Hampshire"])
New_Hampshire_Cluster_Risk

# New Jersey
New_Jersey_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "New Jersey"])
New_Jersey_Cluster_Risk

# New Mexico
New_Mexico_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "New Mexico"])
New_Mexico_Cluster_Risk

# New York
New_York_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "New York"])
New_York_Cluster_Risk

# Oregon
Oregon_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Oregon"])
Oregon_Cluster_Risk

# Pennsylvania
Pennsylvania_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Pennsylvania"])
Pennsylvania_Cluster_Risk

# Rhode Island
Rhode_Island_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Rhode Island"])
Rhode_Island_Cluster_Risk

# Vermont
Vermont_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Vermont"])
Vermont_Cluster_Risk

# Virginia
Virginia_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Virginia"])
Virginia_Cluster_Risk

# Washington
Washington_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Washington"])
Washington_Cluster_Risk

# Wisconsin
Wisconsin_Cluster_Risk <- mean(clusterGroups_Final[State_Polls_Final$state == "Wisconsin"])
Wisconsin_Cluster_Risk
```

Let's take a look at these states in order of most at risk to least at risk for Clinton:

1. Pennsylvania (20)*
2. Michigan (16)*
3. Colorado (9)*
4. New Hampshire (4)*
5. Maine (4)*
6. Wisconsin (10)*
7. New Mexico (5)
8. Virginia (13)
9. Delaware (3)
10. Oregon (7)
11. New Jersey (14)
12. Rhode Island (4)
13. Minnesota (10)
14. Washington (12)
15. Illinois (20)
16. California (55)
17. Connecticut (7)
18. District of Columbia (3)
19. Hawaii (4)
20. Maryland (10)
21. Massachusetts (11)
22. New York (29)
23. Vermont (3)

If we look only at those states with an unrounded mean cluster group score of 1.3 or higher (next to which I have placed an *), and order the list from greatest electoral votes to least, we get the following "at risk" list:

1. Pennsylvania (20)
2. Michigan (16)
3. Wisconsin (10)
4. Colorado (9)
5. New Hampshire (4)
6. Maine (4)

Total Electoral Votes: 63

If the Clinton campaign focuses on these states - particularly Pennsylvania, Michigan, and Wisconsin - Clinton will most likely have an electoral wall strong enough to defend against any encroachment by the Trump campaign. Though Clinton would win by a narrow electoral vote margin (only 8 electoral votes) her chances of winning would be more assured. 

## 2. Offensive/Risky Strategy: Clinton should make a play for the swing states, dedicating resources to states with greatest number of electoral votes. Though Clinton may lose some blue states the result may be a larger overall electoral vote total.

This strategy seeks to maximize electoral votes at greater electoral risk. This strategy isn't entirely irrational: making a push into large swing states could result in a larger electoral vote margin, and may therefore give Clinton greater political capital once in office. In other words, the goal is not just to win but to win big!

If the Clinton campaign chooses this strategy, it makes the most sense to campaign in those swing states with the largest number of electoral votes. Once again, these states include:

1. Florida (29)
2. Ohio (18)
3. North Carolina (15)
4. Arizona (11)
5. Iowa (6)
6. Nevada (6)

Total Electoral Votes: 85

If Clinton were to lose all of her "at risk" states but gained all of the above swing states, the result would be a net gain of 22 electoral votes, bringing her total up to 295. Perhaps this would change the perceptions of Congress, and provide her with additional political capital once in office.

However, if we take into account the hypothetical role of this analysis, namely to provide advice and predictions that will get our hypothetical client elected, then the calculus is clear. If our goal is to help our client attain the requisite number of electoral votes with the highest probability of success, then the only strategy that does both is the conservative strategy.

Therefore, our recommendation is that the Clinton campaign devote resources to shoring up her "at risk" states and to adopt a more defensive strategy.

# So, How Did We Do?

First, let's examine the results of our swing state analysis. Let us define a swing state as a state that had a +/-5% Clinton margin. Below is a list of these states, as well as Clinton's margin in each state:

1. Michigan (-0.22%) 
2. New Hampshire (+0.37%)
3. Pennsylvania (-0.72%)  
4. Wisconsin (-0.76%) 
5. Florida (-1.20%)*
6. Minnesota (+1.52%)
7. Nevada (+2.42%)*
8. Maine (+2.96%)
9. Arizona (-3.55%)*
10. North Carolina (-3.66%)*
11. Colorado (+4.91%)

*Indicates that the state was on our original list of swing states.

Next, let's examine the accuracy of our model when it cames to categorizing solidly Clinton states. Below is a list of states that ended up being solid Clinton wins, which we will define as a Clinton margin greater than +5%:

1. District of Columbia (+86.78%)*
2. Hawaii (+32.18%)*
3. California (+30.11%)*
4. Massachusetts (+27.20%)*
5. Maryland (+26.42%)*
6. Vermont (+26.41%)*
7. New York (+22.49%)*
8. Illinois (+17.06%)*
9. Washington (+15.71%)*
10. Rhode Island (+15.51%)*
12. New Jersey (+14.10%)*
13. Connecticut (+13.64%)*
14. Delaware (+11.37%)*
15. Oregon (+10.98%)*
16. New Mexico (+8.21%)*
17. Virginia (+5.32%)*

*Indicates that the state was on our original list of solidly Clinton states

Finally, let's examine the accuracy of our model when it comes to categorizing solidly Trump states. Below is a list of states that ened up being solid Trump wins, which we will define as a Clinton margin less than -5%:

1. Wyoming (-46.30%)*
2. West Virginia (-42.07%)*
3. Oklahoma (-37.08%)*
4. North Dakota (-35.73%)*
5. Idaho (-31.77%)*
6. Kentucky (-29.84%)*
7. South Dakota (-29.79%)*
8. Alabama (-27.73%)*
9. Arkansas (-26.92%)*
10. Tennessee (-26.01%)*
11. Nebraska (-25.05%)*
12. Kansas (-20.60%)
13. Montana (-20.42%)*
14. Louisiana (-19.64%)*
15. Indiana (-19.17%)
16. Missouri (-18.64%)
17. Utah (-18.08%)
18. Mississippi (-17.83%)*
19. Alaska (-14.73%)
20. South Carolina (-14.27%)
21. Iowa (-9.41%)
22. Texas (-8.99%)
23. Ohio (-8.13%)
24. Georgia (-5.13%)

*Indicates that the state was on our original list of solidly Trump states.

In terms of swing states, we called 4 states out of 11 (a ~36.4% success rate); in terms of solidly Clinton states, we called 17 out of 17 (a 100% success rate); and in terms of solidly Trump states, we called 14 out of 24 (a ~58.3% success rate). Overall, our model accurately categorized ~67% of the states.

If we had randomly assigned a 1/3 chance of assigning a state either as solidly Clinton, solidly Trump, or swing state status then we would have expected a success rate of 1/3 or 33.33%. Clearly our model was more accurate than this baseline.

Next, let's turn to our final prediction. In the end we accurately predicted the winner of every states except 4 - Michigan, Nevada, Pennsylvania, and Wisconsin - a ~92% accuracy rate. If we compare this a random coin toss, we handily beat this baseline assumption of 50%. 

But note! Of those four states we got wrong, three were on our "at risk" list of states: Pennsylvania, Michigan, and Wisconsin. As part of our conservative startegy recommendation we urged the Clinton campaign to dedicate resources to these three states in order to shore up support and to prevent defection - especially given her very narrow and extremely tenuous lead in the electoral college.